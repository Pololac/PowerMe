# ========================================
# CONFIGURATION GLOBALE
# ========================================
stages:
  - test
  - quality
  - build
  - deploy

variables:
  # Node
  NODE_VERSION: 20
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.npm"
  # Maven
  MAVEN_VERSION: 3.9.11
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  # Java
  JAVA_VERSION: 21

  # Docker Registry
  FRONTEND_IMAGE: $CI_REGISTRY_IMAGE/frontend
  BACKEND_IMAGE: $CI_REGISTRY_IMAGE/backend
  # Version de l'image
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  LATEST_TAG: latest

# =============================================
# CACHES POUR ACC√âL√âRER PIPELINE (anchors YAML)
# =============================================
.cache-npm: &cache-npm
  cache:
    key:
      files:
        - frontend/package-lock.json  # Cache invalid√© si package-lock.json change
      prefix: npm-$CI_COMMIT_REF_SLUG
    paths:
      - .npm  # √âvite de re-t√©l√©charger les packages

.cache-maven-sonar: &cache-maven-sonar
  cache:
    - key:
        files:
          - backend/pom.xml
        prefix: maven-$CI_COMMIT_REF_SLUG
      paths:
        - .m2/repository
    - key: sonar-$CI_COMMIT_REF_SLUG
      paths:
        - .sonar/cache


# ========================================
# RULES
# ========================================
.rules-feature-dev: &rules-feature-dev
  - if: '$CI_COMMIT_BRANCH =~ /^feature\/.*/'
  - if: '$CI_COMMIT_BRANCH == "dev"'

.rules-quality: &rules-quality # Sonar "gratuit" n'analyse que la branche par d√©faut ("main")
  # Merge Request vers main (validation avant merge)
  - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'
    when: always
  # Push direct sur main (r√©f√©rence de qualit√©)
  - if: '$CI_COMMIT_BRANCH == "main"'
    when: always

.rules-main-only: &rules-main-only
  - if: '$CI_COMMIT_BRANCH == "main"'


# ========================================
# STAGE 1 : TEST (toujours)
# ========================================
frontend-test:
  stage: test
  rules:
    - changes: ["frontend/**/*"]
    - <<: *rules-feature-dev
  image: trion/ng-cli-karma:latest  # Angular + Chrome inclus
  <<: *cache-npm
  before_script:
    - cd frontend
    - npm ci --prefer-offline
  script:
    - npm run test:ci
  coverage: '/Statements\s*:\s*(\d+\.?\d*)%/'
  artifacts:
    when: always
    reports:
      junit: frontend/coverage/junit.xml       # Pour UI GitLab
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage/                     # Pour SonarCloud
    expire_in: 1 week
  allow_failure: false

backend-test:
  stage: test
  rules:
    - changes: ["backend/**/*"]
    - <<: *rules-feature-dev
  image: maven:${MAVEN_VERSION}-eclipse-temurin-${JAVA_VERSION}-alpine
  <<: *cache-maven-sonar
  services: # N√©cessaire pr BDD tests via Testcontainers en Docker
    - name: docker:24-dind
      alias: docker
  variables:
    DOCKER_HOST: "tcp://docker:2375"  # Permet √† Testcontainers de communiquer avec Docker-in-Docker
    DOCKER_TLS_CERTDIR: ""
    TESTCONTAINERS_RYUK_DISABLED: "true" # Acc√©l√®re la destruction des containers en CI
    TESTCONTAINERS_CHECKS_DISABLE: "true" # Acc√©l√®re encore plus
  before_script:
    - cd backend
  script:
    - mvn clean verify    # Compile + teste + g√©n√®re JaCoCo
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    when: always
    reports:
      junit:
        - backend/target/failsafe-reports/TEST-*.xml  # Pour UI GitLab
        - backend/target/surefire-reports/TEST-*.xml  # Pour UI GitLab
      coverage_report:
        coverage_format: jacoco
        path: backend/target/site/jacoco/jacoco.xml
    paths:
      # Exporter les classes compil√©es pour SonarCloud
      - backend/target/classes/
      - backend/target/test-classes/
      # Rapports pour SonarCloud
      - backend/target/site/jacoco/
      - backend/target/surefire-reports/
    expire_in: 1 week
  allow_failure: false


# ========================================
# STAGE 2 : QUALITY-SonarQube (dev + main)
# ========================================
sonarcloud-frontend:
  stage: quality
  rules:
    - changes: [ "frontend/**/*" ]
    - <<: *rules-quality
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: ${CI_JOB_NAME}
    paths:
      - .sonar/cache
  script:
    - cd frontend
    - sonar-scanner -Dsonar.token=${SONAR_TOKEN}
  needs:
    - frontend-test  # R√©cup√®re le coverage
  allow_failure: true

sonarcloud-backend: # Analyse le code source et lit les tests g√©n√©r√©s par backend-test
  stage: quality
  rules:
    - changes: [ "backend/**/*" ]
    - <<: *rules-quality
  <<: *cache-maven-sonar
  image: maven:${MAVEN_VERSION}-eclipse-temurin-${JAVA_VERSION}-alpine
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
      - backend/.m2/repository
  script:
    - cd backend
    # Analyse avec token + lien CI dynamique
    - |
      mvn sonar:sonar \
        -Dsonar.token=${SONAR_TOKEN} \
        -Dsonar.links.ci=${CI_PROJECT_URL}/-/pipelines
  needs:
    - job: backend-test    # R√©cup√®re les artifacts JaCoCo
      artifacts: true  # R√©cup√®re les classes compil√©es et les rapports JaCoco
  allow_failure: true


# ===========================================
# STAGE 3 : BUILD (main uniquement pour prod)
# ===========================================
build-frontend:
  stage: build
  rules:
    - changes: ["frontend/**/*"]
    - <<: *rules-main-only
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - echo "üîê Connexion au registry GitLab..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - echo "üèóÔ∏è Build image Docker Frontend..."
    - cd frontend
    - docker build
      --build-arg NODE_VERSION=${NODE_VERSION}
      -t ${FRONTEND_IMAGE}:${IMAGE_TAG}
      -t ${FRONTEND_IMAGE}:latest
      .
    - echo "üì§ Push vers registry..."
    - docker push ${FRONTEND_IMAGE}:${IMAGE_TAG}
    - docker push ${FRONTEND_IMAGE}:latest
  after_script:
    - docker logout $CI_REGISTRY

build-backend:
  stage: build
  rules:
    - changes: ["backend/**/*"]
    - <<: *rules-main-only
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - echo "üîê Connexion au registry GitLab..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - echo "üèóÔ∏è Build image Docker Backend..."
    - cd backend
    - docker build
      --build-arg JAVA_VERSION=${JAVA_VERSION}
      -t ${BACKEND_IMAGE}:${IMAGE_TAG}
      -t ${BACKEND_IMAGE}:latest
      .
    - echo "üì§ Push vers registry..."
    - docker push ${BACKEND_IMAGE}:${IMAGE_TAG}
    - docker push ${BACKEND_IMAGE}:latest
  after_script:
    - docker logout $CI_REGISTRY

# ========================================
# STAGE 4: DEPLOY - PROD (automatique)
# ========================================
deploy-prod:
  stage: deploy
  rules:
    - changes:
        - frontend/**/*
        - backend/**/*
        - docker-compose.yml
        - .env
        - .gitlab-ci.yml
    - <<: *rules-main-only
  image: alpine:latest
  needs:
    - build-frontend
    - build-backend
  before_script:
    - echo "üîß Installation des d√©pendances..."
    - apk add --no-cache openssh-client

    - echo "üîê Configuration SSH..."
    - eval $(ssh-agent -s)
    - chmod 400 "$SSH_PRIVATE_KEY"
    - ssh-add "$SSH_PRIVATE_KEY"
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "üöÄ D√©ploiement automatique vers PRODUCTION"
    - echo "üìç Serveur $SSH_HOST"
    - echo "üìÇ R√©pertoire $DEPLOY_DIR"
    - echo "üåê URL $APP_URL"
    - echo "üè∑Ô∏è Version $IMAGE_TAG"

    - |
      ssh $SSH_USER@$SSH_HOST bash -s << 'ENDSSH' "$CI_REGISTRY" "$CI_REGISTRY_USER" "$CI_REGISTRY_PASSWORD" "$IMAGE_TAG" "$DEPLOY_DIR"
        set -e
        
        # R√©cup√©ration des arguments
        REGISTRY=$1
        REGISTRY_USER=$2
        REGISTRY_PASSWORD=$3
        TAG=$4
        DEPLOY_DIR=$5
      
        echo "üìÇ Navigation vers le r√©pertoire de d√©ploiement..."
        cd "$DEPLOY_DIR"
      
        echo "üîê Connexion au registry GitLab..."
        echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      
        echo "üì• R√©cup√©ration des nouvelles images..."
        docker compose pull
      
        echo "üîÑ Mise √† jour des conteneurs..."
        docker compose up -d
      
        echo "üßπ Nettoyage des anciennes images..."
        docker image prune -af --filter "until=24h"
      
        echo "‚úÖ D√©ploiement termin√©!"
      
        echo "üè• V√©rification de la sant√© des services..."
        sleep 5
        docker compose ps
      ENDSSH

    - echo "üéâ D√©ploiement r√©ussi sur $APP_URL"
  environment:
    name: production
    url: $APP_URL


# ========================================
# HEALTHCHECK (optionnel)
# ========================================
healthcheck:
  stage: .post
  <<: *rules-main-only
  image: alpine:latest
  needs:
    - deploy-prod
  script:
    - echo "üè• V√©rification de la sant√© de l'application..."
    - echo "üåê URL test√©e $APP_URL"
    - apk add --no-cache curl
    - |
      for i in {1..10}; do
        HTTP_CODE=$(curl -f -s -o /dev/null -w "%{http_code}" $APP_URL || echo "000")  # ‚Üê UTILISE LA VARIABLE
        if echo "$HTTP_CODE" | grep -q "200\|302"; then
          echo "‚úÖ Application op√©rationnelle (HTTP $HTTP_CODE)!"
          exit 0
        fi
        echo "‚è≥ Tentative $i/10 (HTTP $HTTP_CODE)..."
        sleep 10
      done
      echo "‚ùå L'application ne r√©pond pas!"
      exit 1
  allow_failure: true
